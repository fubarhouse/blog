---
title: Anatomy of an audit
summary: A deep dive into the anatomy of Drutiny
date: 2019-03-13
draft: false
comments: false
tags: ["governance", "automation", "fun"]
---

I bet you've never seen those terms together - "governance" and "fun". Well, I think I am well placed to blog about my experience with an open source Auditing system for Drupal - Drutiny.

I wanted to talk about the structure, and how the pieces fit together as well as how you can/should create your own audits and even provide a single, complete example of a highly customized audit especially made for this blog post.

The intention is to dispel a lot of confusion surrounding this project. It _really_ is a unique project with enormous potential however it does require knowledge, experience and attention for it to continue to thrive.

Drutiny was first conceptually introduced to me during a technical meetup held by the Australian Government Department of Industry and co-managed by myself and the Australian Government Department of Finance.

My speech was around all the reasons individuals in our community should be using composer for Drupal 7 dependency management. Even though those of us in the group with the right level of access is limited to a particuarly small crowd.

The Australian Government Department of Finance brought a representative from Acquia along and talked about the auditing process, teh underlying technology and the reasons behind it. At the time I thought it was interesting though I wasn't working with them directly at the time - this was long before I applied to work with them.

Continuing on, those that specialise in this project and have a significant sum of knowledge have been able to pass a lot of the responsibility onto me.

## Subsections

### Profiles

A Drutiny profile is a structured data file (in YAML) which contains the declaration of a list of policies which include parameters and settings.

A profile will be allocated to any subdirectory of where Drutiny is called from using the filename format `*.profile.yml`. Where `*` represents the machine name of the profile which is called from a terminal.

They can be anywhere, as Drutiny will search `$PWD` recursively for files matching `*.profile.yml` before linting them based upon the required format and structure.

### Policies

A Drutiny policy is the description of an Audit, which does not provide logic associated to the Audit. A policy will simply provide human-readable description under all conditions, it can template the response for the report and it will declare the parameters needed for the Audit to run.

A policy can live anywhere in the codebase, somewhere under the folder where Drutiny was called from. Drutiny will search for any policies matching `*.policy.yml` before linting the files for syntax and structure. 

### Audits

An audit much like policies and profiles can live anywhere, however this is where the grunt of the work happens. Most importantly we need to consider namespacing and autoloading - a number of considerations to be made.

For example, how are you going to structure your project to be compliant with best practices? To make sure your code can be tacked on as a Drutiny dependency, you must use a PHP package to automatically handle autoloading and namespacing.

It doesn't matter where they live, as long as they are properly namepsaced and autoloaded. They are however supposed to be in PSR-4 folder structures, but we'll come back to this.

These major considerations aside, an audit can come in two flavours - an audit which cannot be actioned, and one that can be actioned. The terminology here is "remediate", and by running a profile with the remediate flag, Drutiny will execute a separate function when the policy fails.

## Should we create an audit?

So, with the bulk of the concepts explained we should think about creating an Audit. For this exercise I will provide an example which will be available on Packagist and I'll walk through each step. Last foreword would be that my intention is to run the audit against a vanilla installation of Drupal VM, this is for consistency and reliability - anybody can get started and produce comparative or identical results.

### What you need to follow along.

* Vagrant & VirtualBox (unless you bring your own alternative)
* Composer

### Setting up our test environment.

I'll admit this should be self-explanatory but I will go through this as well.

1. Get your testing environment working!

  ```
  git clone git@github.com:geerlingguy/drupal-vm.git 
  ~/AwesomeAudit
  cd ~/AwesomeAudit
  vagrant up
  ```
2. Verify your testing environment works.

  ```
  drush @drupalvm.www status
  ```

**Note**: The drush alias `@drupalvm.www` will only work when using Drush v9.

### Deciding on a folder structure.

I'm going to provide a folder structure for you to follow - but feel free to change it up. You'll need to update references to that folder in `composer.json` though.

```
root/
  Policies/
  Profiles/
  src/
  composer.json
  composer.lock
```

### Let's get started!

* Drutiny actually recommends their template, so it makes sense we start there. You can see the repository for this over on [GitHub](https://github.com/drutiny/project-dev).

```
composer create-project --no-interaction --prefer-source -s dev drutiny/project-dev drutiny-dev
```

* We can verify it worked by running the following:

```
cd drutiny-dev && bin/drutiny profile:run test @drupalvm.www
```